---
title: "Imports Arbres SE"
author: "Olivier Leroy"
date: "25 avril 2019"
output: html_document
---

# Chargement des bibliothèques 

```{r, echo=FALSE}
### manip
library(dplyr) # manip de données en tidyverse
library(tibble)
library(tidyr)
library(lubridate) # date
library(stringr) # modif sur character

### visualisation
library(ggplot2) # la visualisation
library(tmap) # carto
library(tmaptools) # + outils pour tmap
library(ggmap)# carto +
library(leaflet) # carto web
library(rsconnect) # pour partager une carte
library(RColorBrewer) # des palettes

## analyse spatiale / carto
library(sp) # classes et methodes pour données spatiales pe déclassé par SF
library(rgdal) #gdal pour projection, crud et surtout export
library(rgeos) # geos, penser à installer libgeos++-dev avant, travail avec objet sp
library(sf) # nouveau package de classes et methodes spatiales doit "remplacer" rgdal et rgeos (et ofc sp) 
library(units) # gestion des unités pour ha
library(rmapshaper) #Visvalingam’s algorithm pour ms_simplify
```

# Lecture des données 

```{r}
arbres_se.shp <- st_read("data/arbres_se_brut.geojson", stringsAsFactors = FALSE)
summary(arbres_se.shp)
```

EPSG : 3946

25984 point 

Toutes les infos dans DESCRIPTION qui est une chaine de caractères 

# Recodage des données

```{r}
plot(arbres_se.shp)
```


## Pour le genre

```{r}
# word() permet de sélectionner des "mots"  dans des lignes de caractères, mot étant définit comme separer par whitespace
arbres_se.shp$genus <- word(arbres_se.shp$DESCRIPTION, 1) # ici on peut prendre le premier mot et assumer le genre, genus dans OSM
sort(unique(arbres_se.shp$genus), na.last = F)
```

### Erreurs 

Il y a un "x" en première description et "indéterminé"

#### Pb lié à "x"

```{r}
arbres_se.shp[arbres_se.shp$genus == "x",]
```

Il semble que ce ne sont que les cyprès de Leyland, les Cyprés de Leyland glauque et les chitalpa qui ne soient concernés (36 cas). La meilleure solution est probablement de supprimé le "x"dans le champs DESCRIPTION. 


```{r}
arbres_se.shp$DESCRIPTION[arbres_se.shp$genus == "x"]
```

```{r}
# on remplace DESCRIPTION qui posséde un x par une version sans x
# attention besoin de generer un premier genus
arbres_se.shp$DESCRIPTION[arbres_se.shp$genus == "x"] <- str_remove(arbres_se.shp$DESCRIPTION[arbres_se.shp$genus == "x"],  "\\s|[x]\\s")
```



#### PB lié à "indéterminé"

```{r}
arbres_se.shp[arbres_se.shp$genus == "Indéterminé",]
```

Pour les "indéterminé"s (1072 cas) il me semble que cela correspond à des emplacements vide d'arbres, Ici je suis plus sur l'idée d'un import dans OSM de les supprimé car ils ne correspondent pas à des arbres.

```{r}
arbres_se.shp <- arbres_se.shp %>% 
        filter(! genus == "Indéterminé")
    
summary(arbres_se.shp)
```

### Ré-initialisation de genus


```{r}
arbres_se.shp$genus <- word(arbres_se.shp$DESCRIPTION, 1) # ici on peut prendre le premier mot et assumer le genre, genus dans OSM
unique(arbres_se.shp$genus)
```


## Pour l'espece

```{r}
sort(unique(word(arbres_se.shp$DESCRIPTION, 2)))
```

 Il semble y avoir au moins 4 problèmes "x", "sp.", "" et "inconnu"
 
```{r}
## attention c'est du base R, donc pas ultra lisibile
arbres_se.shp$species <- paste(word(arbres_se.shp$DESCRIPTION, 1), word(arbres_se.shp$DESCRIPTION, 2)) # initialisation
arbres_se.shp$species[word(arbres_se.shp$DESCRIPTION, 2) == ""] <- NA # les espaces en NA pe à verifier
arbres_se.shp$species[word(arbres_se.shp$DESCRIPTION, 2) == "sp."] <- NA # sp en NA
arbres_se.shp$species[word(arbres_se.shp$DESCRIPTION, 2) == "inconnu"] <- NA # inconnu en NA

# pour "x" on va prendre les trois premiers mots pour constituer l'hybride, c'est long car il y a pas mal d'indexation
# on indexe par rapport à "x"
arbres_se.shp$species[word(arbres_se.shp$DESCRIPTION, 2) == "x"] <- paste(word(arbres_se.shp$DESCRIPTION, 1)[word(arbres_se.shp$DESCRIPTION, 2) == "x"], word(arbres_se.shp$DESCRIPTION, 2)[word(arbres_se.shp$DESCRIPTION, 2) == "x"], word(arbres_se.shp$DESCRIPTION, 3)[word(arbres_se.shp$DESCRIPTION, 2) == "x"])

# un test
sort(unique(arbres_se.shp$species), na.last = F)
```
 
 
 Il y a des NA à vérifier
 
 